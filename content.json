{"pages":[],"posts":[{"title":"Android开罐头———外部存储与内部存储完全解析","permalink":"http://www.youyuge.cn/2017/06/02/storage-explaination/","text":"context.getExternalFilesDir(),Environment.getExternalStorageDirectory()，傻傻分不清？到底什么算安卓手机的external storage？ 一、存储概述Android提供了几种保存application持久化数据的选择。而开发者根据 数据是否为app私有 数据是否可以暴露给其他app 数据大小情况 来选择不同的方式存储数据。 1.1 存储方式安卓提供了如下存储的方式选择： 类别 作用 Shared Preferences 以键值对形式在xml中存储配置 Internal Storage （内部存储） 设备中的私有数据 External Storage （外部存储） 共享的外部存储中存公有数据 SQLite Databases 私有数据库存储格式化的数据 Network Connection 在开发者个人网络服务器端存储数据 1.2 content provider安卓提供了一种甚至将app的私有数据提供给其他app的途径————content provider。而android官方guide中不把它归为Strage Options中的一种。 二、Internal Storage 内部存储2.1 内部存储定义 You can save files directly on the device’s internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed. 白话文版本：注意内部存储不是内存。内部存储位于系统中很特殊的一个位置（类似沙盒），如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。 2.2 创建并写入内部存储 Call openFileOutput() with the name of the file and the operating mode. This returns a FileOutputStream. Write to the file with write(). Close the stream with close(). 安卓还为我们提供了一个简便方法Context类的 openFileOutput()来读写应用在内部存储空间上的文件，下面是一个向文件中写入文本的例子： 12345String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);fos.write(string.getBytes());fos.close(); 读取同理，把write()换成read()罢了。 openFileOutput()或者Context.getFileDir()通过Android Device Monitor工具可以找到此目录，为/data/data/com.xxx.xxx/files/。 拓展优化：使用java流，借助FileOutputStream构建出一个OutputStreamWriter对象，接着再用BufferedWriter对象封装： 123FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos));writer.write(string); 2.3 内部存储其他操作 列出所有的已创建的文件,这个可能不容易想到，Context居然有这样的方法。 1234String[] files = Context.fileList();for(String file : files) ｛Log.e(TAG, &quot;file is &quot;+ file);&#125; 删除文件，能创建就要能够删除，当然也会提供了删除文件的接口，它也非常简单，只需要提供文件名 12345if(Context.deleteFile(filename)) &#123;Log.e(TAG, &quot;delete file &quot;+ filename + &quot; sucessfully“);&#125; else &#123;Log.e(TAG, &quot;failed to deletefile &quot; + filename);&#125; 创建一个目录，需要传入目录名称，它返回一个文件对象用到操作路径 12File workDir = Context.getDir(dirName, Context.MODE_PRIVATE);Log.e(TAG, &quot;workdir &quot;+ workDir.getAbsolutePath(); 2.4 内部存储缓存cache你应该使用getCacheDir()来内部绝对缓存目录File，这些缓存将会是在存储不够时第一个被清除的，但是不会保证这些文件一定会被清除。通过Android Device Monitor工具可以找到此目录，为/data/data/com.xxx.xxx/cache/。 Note:你不应该指望着系统来给你清理这些cache文件，你应该自己设定一个合理的最大上限，比如1MB。当用户卸载app时，这些文件同时被卸载。 2.5 内部存储总结 文件操作只需要向函数提供文件名，所以程序自己只需要维护文件名即可； 不用自己去创建文件对象和输入、输出流，提供文件名就可以返回File对象或输入输出流 对于路径操作返回的都是文件对象。 由Context类调用 三、External Storage 外部存储3.1 外部存储定义 Every Android-compatible device supports a shared “external storage” that you can use to save files. This can be a removable storage media (such as an SD card) or an internal (non-removable) storage. Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer. 另外，关于外部存储，我觉得api中在介绍Environment.getExternalStorageDirectory()方法的时候说得很清楚： Note: don’t be confused by the word “external” here. This directory can better be thought as media/shared storage. It is a filesystem that can hold a relatively large amount of data and that is shared across all applications (does not enforce permissions). Traditionally this is an SD card, but it may also be implemented as built-in storage in a device that is distinct from the protected internal storage and can be mounted as a filesystem on a computer. 白话文版本：最容易混淆的是外部存储，如果说pc上也要区分出外部存储和内部存储的话，那么自带的硬盘算是内部存储，U盘或者移动硬盘算是外部存储，因此我们很容易带着这样的理解去看待安卓手机，认为机身固有存储是内部存储，而扩展的TF卡是外部存储。比如我们任务16GB版本的Nexus 4有16G的内部存储，普通消费者可以这样理解，但是安卓的编程中不能，这16GB仍然是外部存储。所有的安卓设备都有外部存储和内部存储，这两个名称来源于安卓的早期设备，那个时候的设备内部存储确实是固定的，而外部存储确实是可以像U盘一样移动的。但是在后来的设备中，很多中高端机器都将自己的机身存储扩展到了8G以上，他们将存储在概念上分成了”内部internal” 和”外部external” 两部分，但其实都在手机内部。所以不管安卓手机是否有可移动的sdcard，他们总是有外部存储和内部存储。最关键的是，我们都是通过相同的api来访问可移动的sdcard或者手机自带的存储（外部存储）。 3.2 获取权限manifest中必须添加： 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; Android 6.0之后新加入了运行时权限，这里不作详解，可参考官方文档： 官方文档：https://developer.android.com/about/versions/marshmallow/android-6.0.html 3.3 检查状态在使用外部存储之前，你必须要使用getExternalStorageState()方法，先检查外部存储的当前状态，以判断是否可用： 1234567891011121314151617/* Checks if external storage is available for read and write */public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;/* Checks if external storage is available to at least read */public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; 3.4 外部存储写入文件获取了权限，检查了状态之后，终于可以写入了，而又有两种类型的文件： 外部存储共有文件 外部存储私有文件 3.4.1 外部存储共有文件 Saving files that can be shared with other apps 公共文件Public files：文件是可以被自由访问，目录任意，且文件的数据对其他应用或者用户来说都是由意义的，当应用被卸载之后，其卸载前创建的文件仍然保留。比如camera应用，生成的照片大家都能访问，而且camera不在了，照片仍然在。举个栗子，下面的方法在公共的图片目录下创建了一个新的图片相册目录： 123456789public File getAlbumStorageDir(String albumName) &#123; // Get the directory for the user&apos;s public pictures directory. File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 注意，如果你的api 版本低于8，那么不能使用getExternalStoragePublicDirectory()，而是使用Environment.getExternalStorageDirectory(),他不带参数，也就不能自己创建一个目录，只是返回外部存储的根路径。 躲避媒体扫描在你的外部目录下放一个名为.nomedia的空文件，则会阻止媒体扫描器通过MediaStore content provider来读取你的媒体文件（比如相册中就不会显示）。但是更好的办法是用下面👇的外部存储私人模式。 3.4.2 外部存储私有文件 If you are handling files that are not intended for other apps to use (such as graphic textures or sound effects used by only your app), you should use a private storage directory on the external storage by calling getExternalFilesDir(). 其实由于是外部存储的原因即是是这种类型的文件也能被其他程序访问，只不过一个应用私有的文件对其他应用其实是没有访问价值的（恶意程序除外）。外部存储上，应用私有文件的价值在于卸载之后，这些文件也会被删除。类似于内部存储。 所有应用程序的外部存储的私有文件都放在根目录的Android/data/下，目录形式为/Android/data/&lt;package_name&gt;/。 Android 4.3及其以下使用getExternalFilesDir()方法可能只会读取手机内部空间，而非SD卡。 使用ContextCompat.getExternalFilesDirs()，或者4.4版本以上使用getExternalFilesDirs()会返回一个File数组，第一个是默认的外部存储。 创建应用私有文件的方法是Context.getExternalFilesDir()，如下： 123456789public File getAlbumStorageDir(Context context, String albumName) &#123;// Get the directory for the app&apos;s private pictures directory.File file = newFile(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES), albumName);if(!file.mkdirs()) &#123;Log.e(LOG_TAG, &quot;Directory not created&quot;);&#125;returnfile;&#125; 上面的代码创建了一个picture目录，并在这个目录下创建了一个名为albumName的文件，Environment.DIRECTORY_PICTURES其实就是字符串picture。 如果你的api 版本低于8，那么不能使用getExternalFilesDir()，而是使用Environment.getExternalStorageDirectory()获得根路径之后，自己再想办法操作/Android/data/&lt;package_name&gt;/下的文件。 注意，媒体扫描器也不能通过MediaStore content provider扫描内部存储私有文件，所以你不应在这里存储照片、音乐。但是别的应用可以读取到他们。 3.5 外部存储缓存 To open a File that represents the external storage directory where you should save cache files, call getExternalCacheDir(). If the user uninstalls your application, these files will be automatically deleted. 调用context的getExternalCacheDir()方法获取外部存储的私有缓存文件夹。 四、各种目录打印最后为了弄清楚getFilesDir，getExternalFilesDir，getExternalStorageDirectory，getExternalStoragePublicDirectory等android文件操作方法，我将这些方法的执行结果打印出来，看看到底路径是啥样，在activity中执行以下代码： 123456Log.i(&quot;codecraeer&quot;, &quot;getFilesDir = &quot; + getFilesDir());Log.i(&quot;codecraeer&quot;, &quot;getExternalFilesDir = &quot; + getExternalFilesDir(&quot;exter_test&quot;).getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getDownloadCacheDirectory = &quot; + Environment.getDownloadCacheDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getDataDirectory = &quot; + Environment.getDataDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getExternalStorageDirectory = &quot; + Environment.getExternalStorageDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getExternalStoragePublicDirectory = &quot; + Environment.getExternalStoragePublicDirectory(&quot;pub_test&quot;)); 在log中看到如下结果： 五、总结一张图总结，我个人的理解是存储按照不同的角度分为两种： 按照内外部：内部存储，外部存储 区别：带External字眼则一定是外部存储的方法，如getExternalFilesDir()，外部存储需要运行时权限 按照共有私有性质：公共文件，私有文件 区别：公共文件是Environment调用函数，而私有文件（包括内部私有与外部私有）是Context调用函数，公共文件不会随着app卸载而删除，私有则会。私有文件不会被Media Scanner扫描到。 引用 android中的文件操作详解以及内部存储和外部存储 http://developer.android.com/training/basics/data-storage/files.html#InternalVsExternalStorage http://developer.android.com/guide/topics/data/data-storage.html https://developer.android.com/about/versions/marshmallow/android-6.0.html"},{"title":"Android罐头————ShapeDrawable详解","permalink":"http://www.youyuge.cn/2017/06/01/Android_ShapeDrawable/","text":"本文对shape这种drawable详细解析，从而可以简单地实现渐变，圆角矩形等等效果的背景。最后有示例。 Drawable种类繁多，ShapeDrawable 是一种很常见的Drawable,可以理解为通过颜色来构造的图形，它既可以是纯色的图形，也可以是具有渐变效果的图形。 一、ShapeDrawable语法ShapeDrawable语法稍显复杂，如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt; &lt;corners android:radius=&quot;integer&quot; android:topLeftRadius=&quot;integer&quot; android:topRightRadius=&quot;integer&quot; android:bottomLeftRadius=&quot;integer&quot; android:bottomRightRadius=&quot;integer&quot; /&gt; &lt;gradient android:angle=&quot;integer&quot; android:centerX=&quot;integer&quot; android:centerY=&quot;integer&quot; android:centerColor=&quot;integer&quot; android:endColor=&quot;color&quot; android:gradientRadius=&quot;integer&quot; android:startColor=&quot;color&quot; android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;] android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt; &lt;padding android:left=&quot;integer&quot; android:top=&quot;integer&quot; android:right=&quot;integer&quot; android:bottom=&quot;integer&quot; /&gt; &lt;size android:width=&quot;integer&quot; android:height=&quot;integer&quot; /&gt; &lt;solid android:color=&quot;color&quot; /&gt; &lt;stroke android:width=&quot;integer&quot; android:color=&quot;color&quot; android:dashWidth=&quot;integer&quot; android:dashGap=&quot;integer&quot; /&gt;&lt;/shape&gt; 需要注意的是&lt;shape&gt;标签创建的Drawable，其实体类实际上是GradientDrawable，下面分别介绍各个属性的含义。 二、各属性含义 android:shape根元素shape表示图形的形状，有四个选项： rectangle 矩形 oval 椭圆 line 横线 ring 圆环 另外四个当中，line 和 ring 一定需要通过&lt;stroke&gt;标签来指定线的宽和和颜色信息等。 &lt;corners&gt;表示shape图形四个交的角度，即四个角的圆角程度。单位是px，只适用于矩形shape。 android:radius优先级较低，会被其他四个属性覆盖。属性含义望文生义即可。注意：每个圆角半径值都必须大于1，否侧就没有圆角。 &lt;solid&gt;表示纯色填充，利用 android:color 就可以指定shape的颜色。 &lt;gradient&gt;渐变效果，和&lt;solid&gt;标签互斥。 gradient标签属性 作用 android:angle 渐变的角度，默认是0，其值必须是45的整数倍。0表示从左边到右，90表示从上到下。具体效果随着角度的调整而产生变化，角度影响渐变方向。 android:centerX 渐变中心的横坐标点 android:centerY 渐变中心的纵坐标点 android:startColor 渐变色的起始色 android:centerColor 渐变色的中间色 android:endColor 渐变色的结束色 android:type 渐变的类型，分3种，linear（线性渐变），radio（径向渐变），sweep（扫描线渐变），默认值是 线性渐变 。 android:gradientRadius 渐变的半径（仅当 android:type 为radio时有效） android:useLevel 一般为false，当Drawable作为StateListDrawable时有效。 &lt;stroke&gt;Shape的描边，有如下几个属性： stroke标签属性 作用 android:width 描边的宽度，越大则shape的边缘线越粗 android:color 描边的颜色 android:dashWidth 虚线的宽度 android:dashGap 虚线的空隙的间隔 注：如果 android:dashWidth 和 android:dashGap 两者有任意一个为0，那么虚线效果就无法显示。 &lt;padding&gt;不是shape的空白，而是包含它的View的空白 &lt;size&gt;shape没有宽/高的概念，总结来说，标签设置的宽高就是ShapeDrawable的固有宽高（这时调用getIntrinsicWidth获得的就不是-1了），但是作为View的背景时，它还是会拉伸或缩小自适应View的大小。 三、示例代码3.1 搜索框渐变背景：xml代码： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;@color/color_fed952&quot; android:endColor=&quot;#ff9b00&quot; /&gt;&lt;/shape&gt; 实际效果： 3.2 搜索框文字背景：xml代码： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;6dp&quot;/&gt; &lt;solid android:color=&quot;@color/white&quot;/&gt;&lt;/shape&gt; 其实就是个editText的背景是白色的圆角矩形，配合上渐变背景，最后搜索框整体效果图： 3.3 搜索框布局文件代码xml代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/bg_home_search&quot; android:padding=&quot;8dp&quot; &gt; &lt;TextView android:id=&quot;@+id/qrcode_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/bar_code_scan_icon&quot; /&gt; &lt;TextView android:id=&quot;@+id/category_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/category&quot; /&gt; &lt;TextView android:id=&quot;@+id/search_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:layout_toLeftOf=&quot;@id/category_view&quot; android:layout_toRightOf=&quot;@id/qrcode_view&quot; android:background=&quot;@drawable/bg_home_edittext&quot; android:gravity=&quot;center&quot; android:padding=&quot;6dp&quot; android:text=&quot;@string/home_edittext_hint&quot; android:textColor=&quot;@color/color_cdcdcd&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/RelativeLayout&gt;"},{"title":"面试罐头（二）---- android插件化面试题","permalink":"http://www.youyuge.cn/2017/05/22/plugin-mianshi/","text":"1. 插件化来由1.1 方法数问题65536为方法数上限 2. 插件化所要解决的问题 动态加载apk 资源加载 代码加载"},{"title":"面试罐头(一)-——-okhttp内部总结分析","permalink":"http://www.youyuge.cn/2017/05/21/mianshi_1/","text":"本文意图是针对面试，理清内部流程关系，而非细抠代码，汇总他人的文字而来。 1.概述okhttp3总体流程图：先来回顾一下代码的使用流程，然后跟着流程一步步来分析： 1.1 创建 OkHttpClient 对象OkHttpClient client = new OkHttpClient(); 其实okHttpClient用的也是builder构建者模式： public OkHttpClient() { this(new Builder()); } 实际上，OkHttpClient.Builder 类成员很多，用来设置连接的各种参数，官方建议使用单例模式构建一个client，这样可以共用缓存和线程池。 直接new只是使用了默认配置： 1234567891011121314151617181920public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000;&#125; 1.2 创建Request请求对象封装了请求报文的信息，用构建者模式构建： Request request = new Request.Builder() .url(url) .build(); 1.3 创建Call对象OkHttpClient 实现了Call.Factory，负责根据请求创建新的 Call。如上图，表示的是链接client和request的桥梁。 callFactory 负责创建 HTTP 请求，HTTP 请求被抽象为了 okhttp3.Call 类，它表示一个已经准备好，可以随时执行的 HTTP 请求 Call call = client.newCall(request); 1.4 同步阻塞执行请求阻塞当前线程： Response response = call.execute(); 1.5 异步回调执行请求不会阻塞当前线程，会新开线程处理 call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { System.out.println(response.body().string()); } }); 2. 精妙的线程池2.1 同步请求时实际上newCall方法会返回一个Realcall对象，而它同步执行execute()方法时： 12345678910111213141516@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; try &#123; //仅仅标记作用 client.dispatcher().executed(this); //这才是真正的执行下一步发请求，同步异步都会走到这个方法 Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 虽然dispatcher也掺和了，其实没什么用，涉及到 dispatcher 的内容只不过是在内部做了个标记，表明有个有个任务正在执行： 1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; 2.2 异步请求2.2.1 反向代理模型服务器会添加Header并自动转发请求给后端集群，接着返回数据结果给用户。可以提高服务的负载均衡能力，实现非阻塞、高可用、高并发连接，避免资源全部放到一台服务器而带来的负载。 而在OkHttp中，非常类似于上述场景，它使用Dispatcher作为任务的派发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque&lt;readyAsyncCalls&gt;对应Nginx的内部缓存。 具体成员如下 maxRequests = 64: 最大并发请求数为64 maxRequestsPerHost = 5: 每个主机最大请求数为5 Dispatcher: 分发者，也就是生产者（默认在主线程） AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口） ExecutorService：消费者池（也就是线程池） Deque&lt;readyAsyncCalls&gt;：缓存（用数组实现，可自动扩容，无大小限制） Deque&lt;runningAsyncCalls&gt;：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存 通过将请求任务分发给多个线程，可以显著的减少I/O等待时间。 2.2.2 异步执行过程具体过程如下： enqueue()方法调用后，判断runningAsyncCalls队列是否还有空位子。 若有空位，那就调用executorService().execute(call);交给线程池执行请求，并且添加进运行队列 啊，没空位了，只能进readyAsyncCalls等待队列了…… 看一下call任务内部的执行方法： ………… //果然和同步方式一样，最后通过这个方法去发送给下一步。 Response response = getResponseWithInterceptorChain(forWebSocket); ………… finally { //最关键的代码 client.dispatcher().finished(this); } 当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数 123456if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //将缓存等待区最后一个移动到运行区中，并执行 i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; 实际上就是会在任务执行完的最后，把自己从运行队列移除，唤醒一个等待队列的任务，让他去执行。这样，就主动的把缓存队列向前走了一步，而没有使用互斥锁等复杂编码。 2.2.3 异步总结 OkHttp采用Dispatcher技术，反向代理，优化了单生产者多消费者模式，与线程池配合实现了高并发，低阻塞的运行 Okhttp采用Deque作为缓存，按照入队的顺序先进先出 OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以在任务结束时候唤醒等待的任务，主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性 3. 工作的核心—-拦截器3.1 拦截器的介绍与种类不管同步异步发送任务请求，最后都会执行getResponseWithInterceptorChain: 123456789101112131415161718private Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor( retryAndFollowUpInterceptor.isForWebSocket())); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 拦截器是个啥？官方介绍和图片： the whole thing is just a stack of built-in interceptors. 可见 Interceptor 是 OkHttp 最核心的一个东西，不要误以为它只负责拦截请求进行一些额外的处理（例如 cookie），实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来，每一个功能都只是一个 Interceptor，它们再连接成一个 Interceptor.Chain，环环相扣，最终圆满完成一次网络请求。 从 getResponseWithInterceptorChain 函数我们可以看到，Interceptor.Chain 的分布依次是： 在配置 OkHttpClient 时设置的 interceptors； 负责失败重试以及重定向的 RetryAndFollowUpInterceptor； 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor； 负责读取缓存直接返回、更新缓存的 CacheInterceptor； 负责和服务器建立连接的 ConnectInterceptor； 配置 OkHttpClient 时设置的 networkInterceptors； 负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor。 3.2 拦截器的责任链模式实际上，是责任链模式的最佳应用（如同事件分发机制），每个拦截器可以自己拦截处理，或者交给下一个拦截器，让每个 Interceptor 自行决定能否完成任务以及怎么完成任务。 其实 Interceptor 的设计也是一种分层的思想，每个 Interceptor 就是一层。为什么要套这么多层呢？分层的思想在 TCP/IP 协议中就体现得淋漓尽致，分层简化了每一层的逻辑，每层只需要关注自己的责任（单一原则思想也在此体现），而各层之间通过约定的接口/协议进行合作（面向接口编程思想），共同完成复杂的任务。 4 总结 OkHttpClient 实现 Call.Factory，负责为 Request 创建 Call； RealCall 为具体的 Call 实现，其 enqueue() 异步接口通过 Dispatcher 利用 ExecutorService 实现，而最终进行网络请求时和同步 execute() 接口一致，都是通过 getResponseWithInterceptorChain() 函数实现； getResponseWithInterceptorChain() 中利用 Interceptor 链条，分层实现缓存、透明压缩、网络 IO 等功能； 引用 OkHttp3源码分析拆轮子系列：拆 OkHttp"},{"title":"hexo快速入门指南","permalink":"http://www.youyuge.cn/2017/05/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"第一篇博客，新的开始","permalink":"http://www.youyuge.cn/2017/05/10/my_first_post_test/","text":"欢迎来到尤晟的博客~ 1. 代码格式展示1.1 代码展示区123public void show()&#123;&#125;"}]}