{"pages":[],"posts":[{"title":"Android开罐头———VectorDrawable实现轨迹动画","permalink":"http://www.youyuge.cn/2017/06/10/vectordrawable-3/","text":"简单利用vectorDrawable的一个属性，就能简单打造出炫酷的路径path轨迹显示效果 效果图： 一、搜索框vectorDrawable代码如下： res/drawable/searchbar.xml12345678910111213141516171819202122&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;150dp&quot; android:height=&quot;24dp&quot; android:viewportHeight=&quot;24&quot; android:viewportWidth=&quot;150&quot;&gt; &lt;path android:name=&quot;search&quot; android:pathData=&quot;M141,17 A9,9 0 1,1 142,16 L149,23&quot; android:strokeAlpha=&quot;0.8&quot; android:strokeColor=&quot;#0092ff&quot; android:strokeLineCap=&quot;round&quot; android:strokeWidth=&quot;2&quot;/&gt; &lt;path android:name=&quot;bar&quot; android:pathData=&quot;M0,23 L149,23&quot; android:strokeAlpha=&quot;0.8&quot; android:strokeColor=&quot;#0092ff&quot; android:strokeLineCap=&quot;square&quot; android:strokeWidth=&quot;2&quot;/&gt;&lt;/vector&gt; 效果图： 二、实现属性动画给放大镜search设置一个从无到有画出来的轨迹属性动画： res/animator/anim_search.xml12345678&lt;objectAnimator xmlns:androd=&quot;http://schemas.android.com/apk/res/android&quot; androd:duration=&quot;1000&quot; androd:propertyName=&quot;trimPathEnd&quot; androd:valueFrom=&quot;0&quot; androd:valueTo=&quot;1&quot; androd:valueType=&quot;floatType&quot;&gt;&lt;/objectAnimator&gt; 其中最重要的参数就是trimPathEnd标签了，同样还有trimPathStart。 trimPathEnd——决定了路径可见部分哪里结束 trimPathStart——决定了路径可见部分哪里开始 如下图所示，trimPathStart为0.27时表示从27%时候，路径开始就可见，而trimPathEnd为0.91时候表示，路径在91%之后就不可见了。所以，我们想用trimPathEnd标签打造从无到有的动画，value值一开始就是0，表示路径到0%结束，后面都不可见，value最后值为1，表示最后路径到100%才结束。 同理，我们想要那个vector里面的bar来一个从有到无的效果，这次我们使用trimPathStart属性来变： res/animator/anim_bar.xml:1234567&lt;objectAnimator xmlns:androd=&quot;http://schemas.android.com/apk/res/android&quot; androd:duration=&quot;1000&quot; androd:propertyName=&quot;trimPathStart&quot; androd:valueFrom=&quot;0&quot; androd:valueTo=&quot;1&quot; androd:valueType=&quot;floatType&quot;&gt;&lt;/objectAnimator&gt; 一开始value为0，表示path从0开始，则表示bar全部显示，最后value为1，表示path从100%初显示，即不显示。 注：大神表示trimPathStart属性使用上更优，所以我们还是最后把vector里的search的属性动画改成trimPathStart变化。 三、粘合剂animated-vector这个就没什么好讲解的了： res/drawable/searchbar_anim.xml: 12345678910111213&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/searchbar&quot;&gt; &lt;target android:animation=&quot;@animator/anim_search&quot; android:name=&quot;search&quot;/&gt; &lt;target android:animation=&quot;@animator/anim_bar&quot; android:name=&quot;bar&quot;/&gt;&lt;/animated-vector&gt; 四、布局中添加vectorDrawable res/layout/acitvity_main.xml:12345&lt;ImageView android:onClick=&quot;anim_vector&quot; app:srcCompat=&quot;@drawable/searchbar_anim&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 在主代码的点击事件中开启动画： MainActivity.java:12345678910//点击事件，开始动画 public void anim_vector(View view)&#123; //获取图标实例 ImageView arrow = (ImageView) view; //判断若是动画则开始 Drawable drawable = arrow.getDrawable(); if(drawable instanceof Animatable)&#123; ((Animatable)drawable).start(); &#125; &#125; 五、效果图与总结效果图： 其实本身还是使用动态vectorDrawable动画，只是简单利用了trim属性，就能打造出炫酷的轨迹效果~"},{"title":"Android开罐头———VectorDrawable实现简单动态动画","permalink":"http://www.youyuge.cn/2017/06/10/vectordrawable-2/","text":"尽管VectorDrawable很强大，体积小，放大不失真，但是这不是我们使用它的最大理由，动态的动画效果才是。 最终效果图： 一、新建图标 右击res目录，利用as自带的图标库vector asset创建一个新的图标file download：123456789&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;100dp&quot; android:height=&quot;100dp&quot; android:viewportWidth=&quot;24.0&quot; android:viewportHeight=&quot;24.0&quot;&gt; &lt;path android:fillColor=&quot;#0092ff&quot; android:pathData=&quot;M19,9h-4V3H9v6H5l7,7 7,-7zM5,18v2h14v-2H5z&quot;/&gt;&lt;/vector&gt; 效果图： 二、创建属性动画 res文件目录下新建animator文件夹后，新建anim.xml文件：12345678&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:duration=&quot;1000&quot; android:propertyName=&quot;translateY&quot; android:repeatCount=&quot;infinite&quot; android:repeatMode=&quot;restart&quot; android:valueFrom=&quot;-5dp&quot; android:valueTo=&quot;0dp&quot; android:valueType=&quot;floatType&quot;/&gt; 我们想让它有个从上到下运动的效果。 三、配置动画粘合剂animated-vector 如何将我们的图标和属性动画联合起来？在代码中去实现？ 不，动画粘合剂animated-vector可以很方便快速连接起vector图标和属性动画animator资源。 在drawable目录下创建anim_vector文件：1234567&lt;animated-vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:drawable=&quot;@drawable/ic_file_download&quot;&gt; &lt;target android:animation=&quot;@animator/anim&quot; android:name=&quot;arrow&quot; /&gt;&lt;/animated-vector&gt; 标签都非常好懂，就是把target里的动画运用到根标签drawable里的vector中。 但是上面的target标签必须指定name，这里的name对应vector图标里指定的name标签，这样就能很方便地根据name来区分复杂vector图标里的不同path（类似布局文件里的id作用），从而对不同的path在animated-vector 里使用不同的动画。 所以我们回到vector文件中，因为我们只想让箭头动，所以把它俩从同一path中拆分出来，并且只给箭头的path加上name，这样animated-vector粘合剂里就可以只给箭头加动画了。修改后如下：1234567891011121314&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;100dp&quot; android:height=&quot;100dp&quot; android:viewportWidth=&quot;24.0&quot; android:viewportHeight=&quot;24.0&quot;&gt; &lt;path android:name=&quot;arrow&quot; android:fillColor=&quot;#0092ff&quot; android:pathData=&quot;M19,9h-4V3H9v6H5l7,7 7,-7z&quot;/&gt; &lt;path android:name=&quot;line&quot; android:fillColor=&quot;#004d85&quot; android:pathData=&quot;M5,18v2h14v-2H5z&quot;/&gt;&lt;/vector&gt; 效果图： 四、添加粘合剂animated-vector到布局 接下来我们要把动画vector部署到主活动的布局文件中去了：1234567&lt;ImageView android:onClick=&quot;anim_vector&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_below=&quot;@id/rec&quot; app:srcCompat=&quot;@drawable/anim_vector&quot; /&gt; app:srcCompat标签中的资源就是我们第三步中的粘合剂animated-vector 还要在代码中去写点击事件，点击后开始动画： 12345678910//点击事件，开始动画 public void anim_vector(View view)&#123; //获取图标实例 ImageView arrow = (ImageView) view; //判断若是动画则开始 Drawable drawable = arrow.getDrawable(); if(drawable instanceof Animatable)&#123; ((Animatable)drawable).start(); &#125; &#125; 终于搞定了，现在我们在机子上点击图标试试，啊？怎么动画不动？发现有句警告的log： 1Method setTranslateX() with type float not found on target class ——————————— 大坑注意：属性动画是通过改变属性的值而生效，但是这里例子里，我们作用于vector图标，可是path标签是没有translateX值的。所以我们需要用到group标签。 ———————————五、为vector适配属性动画上面说到了，需要增加group标签来包裹path标签，group标签的作用有： 给path分组 提供path没有的一些属性，如：translateX，rotation等等 这样，让属性动画作用于group就能实现位移效果了，修改后的vector图标代码(记得把name标签移到group中)：1234567891011121314151617&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;100dp&quot; android:height=&quot;100dp&quot; android:viewportHeight=&quot;24.0&quot; android:viewportWidth=&quot;24.0&quot;&gt; &lt;group android:name=&quot;arrow&quot;&gt; &lt;path android:fillColor=&quot;#0092ff&quot; android:pathData=&quot;M19,9h-4V3H9v6H5l7,7 7,-7z&quot; /&gt; &lt;/group&gt; &lt;group android:name=&quot;line&quot;&gt; &lt;path android:fillColor=&quot;#004d85&quot; android:pathData=&quot;M5,18v2h14v-2H5z&quot; /&gt; &lt;/group&gt;&lt;/vector&gt; 六、效果图与总结 效果图： 总结：在gradle配置成功的基础之上，vectorDrawable的属性动画效果实现还是比较简单的，而且能动态分组实现。"},{"title":"Android开罐头———初识VectorDrawable","permalink":"http://www.youyuge.cn/2017/06/09/vectordrawable-1/","text":"什么是矢量动画？我们为何要使用它？如何生成？和SVG有什么区别? 一、矢量图SVG和VectorDrawable1.1 SVG和Vector差异 SVG—-前端中使用，是一套有很多标签的语法规范 Vector—-在Android中使用，Vector只实现了SVG语法的Path标签 1.2 Android不直接使用SVG的原因SVG解析效率低下，Android只使用Path标签去绘制图形，语句复杂但是效率大大提升了，和canvas理由类似。同时，文件体积上，vector&lt;svg&lt;&lt;png 1.3 Vector语法pathData标签一般由字母跟数字组成，字母多为命令关键字（这里有个大小写的区别，大写的字母是基于原点坐标系的偏移量，即绝对位置；小写字母是基于当前点坐标系的偏移量，即相对位置），数字多为坐标， M(x y): 没什么好说的，移动画笔到指定点，并不进行绘制，默认在(0,0)点。与Paint里面moveTo可以理解成一样的概念 L(l) (x y) : 画直线，与它类似的有H(h)跟V(v)。这里有一个方向的概念，pathData中的方向与View绘制的方向是一样的。H就是画一条横线，V就是画一条竖线，L就是画点到点之间的线 Z :没有参数，就是连接起点跟终点 二、生成矢量图VectorDrawable2.1 as自带 右键res，选择vector asset后选择 2.2 svg导入 网址在线制作svg 阿里的矢量图标下载 2.3 自己编写如下,其中android:viewportHeight表示把宽高分成几份，这样在pathData中可以用份数做单位，从而下次可以直接改宽高dp，而不用改pathData 12345678910&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:width=&quot;24dp&quot; android:height=&quot;24dp&quot; android:viewportHeight=&quot;200&quot; android:viewportWidth=&quot;200&quot;&gt; &lt;path android:fillColor=&quot;#dc33cdcd&quot; android:pathData=&quot;M100,100 L150,100 L150,150 L100,150 Z&quot;/&gt;&lt;/vector&gt; 效果图就是一个青色的正方形： 三、VectorDrawable兼容性3.1 兼容性的坎坷之路 Android L （5.0）是它的诞生，但是只允许API&gt;=21的设备使用，基本残废 Gradle Plugin 1.5 是一个里程碑，设备&gt;=21则使用vector，设备&lt;21则将vector在编译时转化为png使用，局限性很大 AppCompat 23.2 才是真正的春天，静态vector支持到android2.1+，动态vector支持到android3.0+，于是几乎兼容所有的设备 四、静态VectorDrawable的配置与应用4.1 gradle项目配置 app子项目的bulid.gradle下添加一句话： 12345android &#123; defaultConfig &#123; vectorDrawables.useSupportLibrary = true &#125;&#125; 确保AppCompat兼容库版本为23.2以上 同时更新根目录下bulid.gradle中的Gradle Plugin 版本，至少要升级到2.1以上，否则还是会自动转换vector为png(原因见3.1） 1classpath &apos;com.android.tools.build:gradle:2.3.1&apos; 4.2 控件使用vectorDrawable4.2.1 ImageView/ImageButtonImageView/ImageButton设置背景，直接用标签app:srcCompat123456&lt;ImageView android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; app:srcCompat=&quot;@drawable/ic_camera&quot; /&gt; 4.2.2 ButtonButton设置背景不能直接使用标签app:srcCompat，只能利用selector标签间接引用 selector文件如下： 123456&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:drawable=&quot;@drawable/ic_rec&quot; android:state_pressed=&quot;false&quot;/&gt; &lt;item android:drawable=&quot;@drawable/ic_camera&quot; android:state_pressed=&quot;true&quot;/&gt;&lt;/selector&gt; Button设置背景为selector:123456&lt;Button android:layout_width=&quot;100dp&quot; android:layout_height=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:layout_below=&quot;@id/camera_imageview&quot; android:background=&quot;@drawable/button_bg&quot;/&gt; 大坑注意还要在代码中加以下这句话：123static &#123; AppCompatDelegate.setCompatVectorFromResourcesEnabled(true);&#125; 4.3 总结使用低版本的手机进行实验，若是显示成功则说明配置成功了。最终效果图："},{"title":"Android开罐头———快速打造扇形卫星菜单","permalink":"http://www.youyuge.cn/2017/06/08/circle-menu/","text":"属性动画，快速打造，练手用 预览图： 一、制作圆形图标很方便地利用as自动生成圆形图标： 右击res，选择Image Asset: 选择Launcher Icons，然后选Square,其余自己调整： 现在，mipmap中有了相关图片~~当然，普通icon加个shape也是很方便的~ 二、布局文件很简单，新建一个布局文件，记得把加号图标放最下面，这样就能遮住别的图标，直接上代码了: //layout/circle_menu_layout.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentBottom=&quot;true&quot; android:layout_alignParentRight=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/circle_menu_button_2&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot; android:src=&quot;@mipmap/ic_edit1&quot; /&gt; &lt;ImageView android:id=&quot;@+id/circle_menu_button_3&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot; android:src=&quot;@mipmap/ic_star&quot; /&gt; &lt;ImageView android:id=&quot;@+id/circle_menu_button_4&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot; android:src=&quot;@mipmap/ic_cloud&quot; /&gt; &lt;ImageView android:id=&quot;@+id/circle_menu_button_5&quot; android:layout_width=&quot;40dp&quot; android:layout_height=&quot;40dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;15dp&quot; android:layout_marginRight=&quot;15dp&quot; android:src=&quot;@mipmap/ic_look&quot; /&gt; &lt;ImageView android:id=&quot;@+id/circle_menu_button_1&quot; android:layout_width=&quot;50dp&quot; android:layout_height=&quot;50dp&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_marginBottom=&quot;12dp&quot; android:layout_marginRight=&quot;12dp&quot; android:src=&quot;@mipmap/ic_add&quot; /&gt;&lt;/FrameLayout&gt; 在总的布局文件中，直接include引入即可： 1&lt;include layout=&quot;@layout/circle_menu_layout&quot; /&gt; 三、代码中使用属性动画 首先定义变量，分别是资源id数组，图片队列，用来标明开关状态的标志位 12345//扇形菜单按钮private int res[] =&#123;R.id.circle_menu_button_1,R.id.circle_menu_button_2,R.id.circle_menu_button_3,R.id.circle_menu_button_4,R.id.circle_menu_button_5&#125;;private ArrayList&lt;ImageView&gt; imageViews = new ArrayList&lt;&gt;();//菜单是否展开的flag,false表示没展开private boolean mFlag = false; 利用for循环初始化图标实例 12345for (int i = 0; i &lt; res.length; i++) &#123; ImageView imageView = (ImageView) mContentView.findViewById(res[i]); imageView.setOnClickListener(this); imageViews.add(imageView); &#125; 在点击事件onClick()中，判断开关状态后，开启进入或者退出的动画方法 12345678910case R.id.circle_menu_button_1: if (mFlag == false)&#123; showEnterAnim(100); //100为扇形半径dp值 &#125;else &#123; showExitAnim(100); &#125; break;``` - 下面来看看最重要的`showEnterAnim()`方法: //显示扇形菜单的属性动画 private void showEnterAnim(int dp) { //for循环来开始小图标的出现动画 for (int i = 1; i &lt; res.length; i++) { AnimatorSet set = new AnimatorSet(); double x = -Math.cos(0.5/(res.length-2)(i-1)Math.PI) Utils.dip2px(mContext,dp); double y = -Math.sin(0.5/(res.length-2)(i-1)Math.PI) Utils.dip2px(mContext,dp); set.playTogether( ObjectAnimator.ofFloat(imageViews.get(i),”translationX”,(float)(x0.25),(float)x), ObjectAnimator.ofFloat(imageViews.get(i),”translationY”,(float)(y0.25),(float)y) ,ObjectAnimator.ofFloat(imageViews.get(i),”alpha”,0,1).setDuration(2000) ); set.setInterpolator(new BounceInterpolator()); set.setDuration(500).setStartDelay(100*i); set.start(); }//转动加号大图标本身45° ObjectAnimator rotate = ObjectAnimator.ofFloat(imageViews.get(0),”rotation”,0,45).setDuration(300); rotate.setInterpolator(new BounceInterpolator()); rotate.start(); //菜单状态置打开 mFlag = true; } 1234567唯一的难点就是根据第几个小图标，计算小图标的xy轴坐标了，注意三角函数`Math.sin()`的参数不是度数，而是**弧度制**的角度大小。- 退出动画其实和上面是相反的操作，参数前后换一下即可，但是考虑到是退出，所以应该时间短一点，变透明得快一点，且差值器就不用回弹效果了,可以用减速器的差值器（这样一开始可以速度快点），代码就不贴了。- 上面用到了一个工具类函数`Utils.dip2px()`转换dp参数为px值，如下： public static int dip2px(Context context, float dpValue) { final float scale = context.getResources().getDisplayMetrics().density; return (int) (dpValue * scale); }``` 四、总结实现效果： 总的来说，属性动画可以快速方便地实现较为炫酷的效果，要自己多写几个经典的demo试试就行了。下一步可以学习更为厉害的VectorDrawable和贝塞尔曲线等等~~"},{"title":"Android开罐头———打造动漫二次元加载读取的自定义dialog","permalink":"http://www.youyuge.cn/2017/06/04/dialog-made-by-myself/","text":"自定义dialog当然已经被写烂咯，本文的重点是很方便地获取二次元动漫动图。自带的progress dialog看腻了吗？来换个和bilibili一样的动漫二次元加载吧！ 一、动画来源获取1.1 来源简介先来预览下效果咯： 很萌很萌吧！！！loading动画当然还是帧动画咯，由于是二次元，pixiv（俗称p站）可谓是动漫图片最多的站点了，上面有数以亿计的动漫图片和动图。 pixiv :新兴的日本同人画、插画作品分享站点。采用了web2.0的方式，每个参与者都有自己的主页并可以对作品评价打分。 但是由于版权的保护性政策，动图是无法直接下载到gif的，所以我们必须通过一些非常规手段获取，巧合的是，获取到的是动画帧的图片压缩包，所以可以直接拿来当做安卓开发的帧动画使用！ 1.2 动画帧获取p站如今支持中文，所以阅读上没有了障碍，大家可以搜索自己喜欢主题的动图，或者直接去每日排行榜获取高人气动图，我们以此链接 为例。 使用chrome内核的浏览器，右键选择检查： 进入开发者工具界面后，按下Ctrl+F（Command+F）搜索关键词zip,其实已经可以看到我们要的下载链接了，但是不能直接复制，必须选中整个段落后，右键copy到文本编辑器中。 在文本编辑器中，删除所有的转义字符\\后，复制名字里带有600x600的那个zip链接，然后粘贴到浏览器或者迅雷中下载。 解压后即可获得动画帧图片，顺序为名称。 ###警告：pixiv站点所有图片拥有版权©️，商用请联系原作者，下载仅仅是个人学习参考之用。 二、帧动画xml文件的建立怕是没有人不会吧，直接贴代码了，具体的duration根据实际情况自己调节： 12345678910111213141516171819202122232425262728293031323334353637&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;false&quot;&gt; &lt;item android:drawable=&quot;@drawable/loading_1&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_2&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_3&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_4&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_5&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_6&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_7&quot; android:duration=&quot;100&quot; /&gt; &lt;item android:drawable=&quot;@drawable/loading_8&quot; android:duration=&quot;100&quot; /&gt;&lt;/animation-list&gt; 三、自定义dialog的建立3.1 Dialog概念dialog的官方定义： A dialog is a small window that prompts the user to make a decision or enter additional information. A dialog does not fill the screen and is normally used for modal events that require users to take an action before they can proceed. 先来了解下什么是Window： Window表示窗口的概念，它实际上是View的直接管理者，包括View的视图创建，事件分发机制都必须先经过Window。 自定义Dialog，要先明确Dialog的地位。 View是android中视图的呈现方式，但是View不能单独存在，必须依附在Window窗口这个抽象概念上，而Android中提供视图的地方有Activity，Dialog，Toast。 所以某种程度上来说，Dialog是和活动平起平坐的，Dialog的Window创建过程与Activity类似（几乎没区别），所以Dialog也有setContentView方法。具体的创建过程可以参考《Android开发艺术探索》这本书。 所以我们在后面想要管理Dialog的对话框大小就必须使用WindowManager类，而不是去设置父布局的params。 3.2 建立dialog布局文件直接上代码了，注意，我直接在布局最外层设定了固定的大小，且使用了一个圆角半透明矩形shape作为背景。 1234567891011121314151617181920212223242526272829303132333435&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;120dp&quot; android:layout_height=&quot;120dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/shape_dialog_bg&quot; android:layout_centerInParent=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;10dp&quot;&gt; &lt;ImageView android:id=&quot;@+id/loading_view&quot; android:layout_width=&quot;85dp&quot; android:layout_height=&quot;85dp&quot; android:scaleType=&quot;fitCenter&quot; android:layout_centerInParent=&quot;true&quot; android:src=&quot;@drawable/loading_data_anim&quot; /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/tv_load_dialog&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;读取中……&quot; android:layout_marginTop=&quot;5dp&quot; android:textColor=&quot;@color/color_666666&quot; android:textSize=&quot;12sp&quot;/&gt;&lt;/LinearLayout&gt; 效果图： 3.3 自定义dialog的建立 我们新建一个类LoadingDialog继承自Dialog,初始化布局参数： 12345678910111213141516private void initView() &#123; setContentView(R.layout.dialog_loading_layout); imageView = (ImageView) findViewById(R.id.loading_view); //启动我们的二次元帧动画 AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable(); animationDrawable.start(); //获取WindowManager.LayoutParams来管理dialog最外部window的大小，理由在3.1 节中已经说明。其实这里不用设置，因为我们在布局最外层指定了居中，且设为固定大小 后对话框最外层布局会自适应（但是android5.0以上默认最外布局match_parent）。 WindowManager.LayoutParams params = getWindow().getAttributes(); params.gravity = Gravity.CENTER; params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.height = WindowManager.LayoutParams.WRAP_CONTENT; getWindow().setAttributes(params); &#125; 但是坑来了，尽管我们设定了最外层布局为WRAP_CONTENT，但是它是默认白色的背景，所以我们的圆角矩形效果就失效了，借@青蛙要fly的一张图，如果设定background为黑色则效果更加直观： 解决的办法很简单，直接覆盖重写dialog style里的透明属性即可，另外，使用兼容包的dialog样式默认没有Title了，但是这里还是覆写一下： 1234&lt;style name=&quot;dialog_no_title&quot; parent=&quot;Theme.AppCompat.Dialog&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 在构造函数中传入我们的新style（dialog提供了这个构造方法）： 1234public LoadingDialog(Context context) &#123; super(context,R.style.LoadingDialog); mContext=context; &#125; 最后我们的自定义dialog就已经完成了,贴上完整代码： 12345678910111213141516171819202122232425262728293031323334public class LoadingDialog extends Dialog &#123; private Context mContext; ImageView imageView; public LoadingDialog(Context context) &#123; super(context,R.style.LoadingDialog); mContext=context; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); &#125; private void initView() &#123; setContentView(R.layout.dialog_loading_layout); imageView = (ImageView) findViewById(R.id.loading_view); AnimationDrawable animationDrawable = (AnimationDrawable) imageView.getDrawable(); animationDrawable.start(); WindowManager.LayoutParams params = getWindow().getAttributes(); params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.height = WindowManager.LayoutParams.WRAP_CONTENT; getWindow().setAttributes(params); &#125; @Override public void dismiss() &#123; super.dismiss(); &#125;&#125; 四、封装构建Dialog管理类为了效率和复用性，我们使用单例模式封装一个线程安全的DialogManger类： 123456789101112131415161718192021222324252627282930313233343536public class DialogManager &#123; private static DialogManager mInstnce = null; private ProgressDialog mDialog; public static DialogManager getInstnce() &#123; if (mInstnce == null) &#123; //线程安全模式 synchronized (DialogManager.class) &#123; if (mInstnce == null) &#123; mInstnce = new DialogManager(); &#125; &#125; &#125; return mInstnce; &#125; public void showProgressDialog(Context context) &#123; if (mDialog == null) &#123; mDialog = new ProgressDialog(context); //设置点击dialog外部，不会自动退出dialog mDialog.setCanceledOnTouchOutside(false); &#125; mDialog.show(); &#125; public void dismissProgressDialog() &#123; if (mDialog != null) &#123; mDialog.dismiss(); &#125; mDialog = null; &#125;&#125; 这样，我们就可以一句话调出和取消读取界面了： 1234//显示 DialogManager.getInstnce().showProgressDialog(this); //取消显示 DialogManager.getInstnce().dismissProgressDialog(); 五、总结其实整个过程非常简单，就是理解window类，然后自定义一个dialog，然后在dialog中启动帧动画，有些老生常谈的坑需要注意罢了。再来看一眼我们萌萌的loading动画吧："},{"title":"Android开罐头———外部存储与内部存储完全解析","permalink":"http://www.youyuge.cn/2017/06/02/storage-explaination/","text":"context.getExternalFilesDir(),Environment.getExternalStorageDirectory()，傻傻分不清？到底什么算安卓手机的external storage？ 一、存储概述Android提供了几种保存application持久化数据的选择。而开发者根据 数据是否为app私有 数据是否可以暴露给其他app 数据大小情况 来选择不同的方式存储数据。 1.1 存储方式安卓提供了如下存储的方式选择： 类别 作用 Shared Preferences 以键值对形式在xml中存储配置 Internal Storage （内部存储） 设备中的私有数据 External Storage （外部存储） 共享的外部存储中存公有数据 SQLite Databases 私有数据库存储格式化的数据 Network Connection 在开发者个人网络服务器端存储数据 1.2 content provider安卓提供了一种甚至将app的私有数据提供给其他app的途径————content provider。而android官方guide中不把它归为Strage Options中的一种。 二、Internal Storage 内部存储2.1 内部存储定义 You can save files directly on the device’s internal storage. By default, files saved to the internal storage are private to your application and other applications cannot access them (nor can the user). When the user uninstalls your application, these files are removed. 白话文版本：注意内部存储不是内存。内部存储位于系统中很特殊的一个位置（类似沙盒），如果你想将文件存储于内部存储中，那么文件默认只能被你的应用访问到，且一个应用所创建的所有文件都在和应用包名相同的目录下。也就是说应用创建于内部存储的文件，与这个应用是关联起来的。当一个应用卸载之后，内部存储中的这些文件也被删除。 内部存储空间十分有限，因而显得可贵，另外，它也是系统本身和系统应用程序主要的数据存储所在地，一旦内部存储空间耗尽，手机也就无法使用了。所以对于内部存储空间，我们要尽量避免使用。Shared Preferences和SQLite数据库都是存储在内部存储空间上的。内部存储一般用Context来获取和操作。 2.2 创建并写入内部存储 Call openFileOutput() with the name of the file and the operating mode. This returns a FileOutputStream. Write to the file with write(). Close the stream with close(). 安卓还为我们提供了一个简便方法Context类的 openFileOutput()来读写应用在内部存储空间上的文件，下面是一个向文件中写入文本的例子： 12345String FILENAME = &quot;hello_file&quot;;String string = &quot;hello world!&quot;;FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);fos.write(string.getBytes());fos.close(); 读取同理，把write()换成read()罢了。 openFileOutput()或者Context.getFileDir()通过Android Device Monitor工具可以找到此目录，为/data/data/com.xxx.xxx/files/。 拓展优化：使用java流，借助FileOutputStream构建出一个OutputStreamWriter对象，接着再用BufferedWriter对象封装： 123FileOutputStream fos = openFileOutput(FILENAME, Context.MODE_PRIVATE);BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fos));writer.write(string); 2.3 内部存储其他操作 列出所有的已创建的文件,这个可能不容易想到，Context居然有这样的方法。 1234String[] files = Context.fileList();for(String file : files) ｛Log.e(TAG, &quot;file is &quot;+ file);&#125; 删除文件，能创建就要能够删除，当然也会提供了删除文件的接口，它也非常简单，只需要提供文件名 12345if(Context.deleteFile(filename)) &#123;Log.e(TAG, &quot;delete file &quot;+ filename + &quot; sucessfully“);&#125; else &#123;Log.e(TAG, &quot;failed to deletefile &quot; + filename);&#125; 创建一个目录，需要传入目录名称，它返回一个文件对象用到操作路径 12File workDir = Context.getDir(dirName, Context.MODE_PRIVATE);Log.e(TAG, &quot;workdir &quot;+ workDir.getAbsolutePath(); 2.4 内部存储缓存cache你应该使用getCacheDir()来内部绝对缓存目录File，这些缓存将会是在存储不够时第一个被清除的，但是不会保证这些文件一定会被清除。通过Android Device Monitor工具可以找到此目录，为/data/data/com.xxx.xxx/cache/。 Note:你不应该指望着系统来给你清理这些cache文件，你应该自己设定一个合理的最大上限，比如1MB。当用户卸载app时，这些文件同时被卸载。 2.5 内部存储总结 文件操作只需要向函数提供文件名，所以程序自己只需要维护文件名即可； 不用自己去创建文件对象和输入、输出流，提供文件名就可以返回File对象或输入输出流 对于路径操作返回的都是文件对象。 由Context类调用 三、External Storage 外部存储3.1 外部存储定义 Every Android-compatible device supports a shared “external storage” that you can use to save files. This can be a removable storage media (such as an SD card) or an internal (non-removable) storage. Files saved to the external storage are world-readable and can be modified by the user when they enable USB mass storage to transfer files on a computer. 另外，关于外部存储，我觉得api中在介绍Environment.getExternalStorageDirectory()方法的时候说得很清楚： Note: don’t be confused by the word “external” here. This directory can better be thought as media/shared storage. It is a filesystem that can hold a relatively large amount of data and that is shared across all applications (does not enforce permissions). Traditionally this is an SD card, but it may also be implemented as built-in storage in a device that is distinct from the protected internal storage and can be mounted as a filesystem on a computer. 白话文版本：最容易混淆的是外部存储，如果说pc上也要区分出外部存储和内部存储的话，那么自带的硬盘算是内部存储，U盘或者移动硬盘算是外部存储，因此我们很容易带着这样的理解去看待安卓手机，认为机身固有存储是内部存储，而扩展的TF卡是外部存储。比如我们任务16GB版本的Nexus 4有16G的内部存储，普通消费者可以这样理解，但是安卓的编程中不能，这16GB仍然是外部存储。所有的安卓设备都有外部存储和内部存储，这两个名称来源于安卓的早期设备，那个时候的设备内部存储确实是固定的，而外部存储确实是可以像U盘一样移动的。但是在后来的设备中，很多中高端机器都将自己的机身存储扩展到了8G以上，他们将存储在概念上分成了”内部internal” 和”外部external” 两部分，但其实都在手机内部。所以不管安卓手机是否有可移动的sdcard，他们总是有外部存储和内部存储。最关键的是，我们都是通过相同的api来访问可移动的sdcard或者手机自带的存储（外部存储）。 3.2 获取权限manifest中必须添加： 1234&lt;manifest ...&gt; &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt; ...&lt;/manifest&gt; Android 6.0之后新加入了运行时权限，这里不作详解，可参考官方文档： 官方文档：https://developer.android.com/about/versions/marshmallow/android-6.0.html 3.3 检查状态在使用外部存储之前，你必须要使用getExternalStorageState()方法，先检查外部存储的当前状态，以判断是否可用： 1234567891011121314151617/* Checks if external storage is available for read and write */public boolean isExternalStorageWritable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state)) &#123; return true; &#125; return false;&#125;/* Checks if external storage is available to at least read */public boolean isExternalStorageReadable() &#123; String state = Environment.getExternalStorageState(); if (Environment.MEDIA_MOUNTED.equals(state) || Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; return true; &#125; return false;&#125; 3.4 外部存储写入文件获取了权限，检查了状态之后，终于可以写入了，而又有两种类型的文件： 外部存储共有文件 外部存储私有文件 3.4.1 外部存储共有文件 Saving files that can be shared with other apps 公共文件Public files：文件是可以被自由访问，目录任意，且文件的数据对其他应用或者用户来说都是由意义的，当应用被卸载之后，其卸载前创建的文件仍然保留。比如camera应用，生成的照片大家都能访问，而且camera不在了，照片仍然在。举个栗子，下面的方法在公共的图片目录下创建了一个新的图片相册目录： 123456789public File getAlbumStorageDir(String albumName) &#123; // Get the directory for the user&apos;s public pictures directory. File file = new File(Environment.getExternalStoragePublicDirectory( Environment.DIRECTORY_PICTURES), albumName); if (!file.mkdirs()) &#123; Log.e(LOG_TAG, &quot;Directory not created&quot;); &#125; return file;&#125; 注意，如果你的api 版本低于8，那么不能使用getExternalStoragePublicDirectory()，而是使用Environment.getExternalStorageDirectory(),他不带参数，也就不能自己创建一个目录，只是返回外部存储的根路径。 躲避媒体扫描在你的外部目录下放一个名为.nomedia的空文件，则会阻止媒体扫描器通过MediaStore content provider来读取你的媒体文件（比如相册中就不会显示）。但是更好的办法是用下面👇的外部存储私人模式。 3.4.2 外部存储私有文件 If you are handling files that are not intended for other apps to use (such as graphic textures or sound effects used by only your app), you should use a private storage directory on the external storage by calling getExternalFilesDir(). 其实由于是外部存储的原因即是是这种类型的文件也能被其他程序访问，只不过一个应用私有的文件对其他应用其实是没有访问价值的（恶意程序除外）。外部存储上，应用私有文件的价值在于卸载之后，这些文件也会被删除。类似于内部存储。 所有应用程序的外部存储的私有文件都放在根目录的Android/data/下，目录形式为/Android/data/&lt;package_name&gt;/。 Android 4.3及其以下使用getExternalFilesDir()方法可能只会读取手机内部空间，而非SD卡。 使用ContextCompat.getExternalFilesDirs()，或者4.4版本以上使用getExternalFilesDirs()会返回一个File数组，第一个是默认的外部存储。 创建应用私有文件的方法是Context.getExternalFilesDir()，如下： 123456789public File getAlbumStorageDir(Context context, String albumName) &#123;// Get the directory for the app&apos;s private pictures directory.File file = newFile(context.getExternalFilesDir(Environment.DIRECTORY_PICTURES), albumName);if(!file.mkdirs()) &#123;Log.e(LOG_TAG, &quot;Directory not created&quot;);&#125;returnfile;&#125; 上面的代码创建了一个picture目录，并在这个目录下创建了一个名为albumName的文件，Environment.DIRECTORY_PICTURES其实就是字符串picture。 如果你的api 版本低于8，那么不能使用getExternalFilesDir()，而是使用Environment.getExternalStorageDirectory()获得根路径之后，自己再想办法操作/Android/data/&lt;package_name&gt;/下的文件。 注意，媒体扫描器也不能通过MediaStore content provider扫描内部存储私有文件，所以你不应在这里存储照片、音乐。但是别的应用可以读取到他们。 3.5 外部存储缓存 To open a File that represents the external storage directory where you should save cache files, call getExternalCacheDir(). If the user uninstalls your application, these files will be automatically deleted. 调用context的getExternalCacheDir()方法获取外部存储的私有缓存文件夹。 四、各种目录打印最后为了弄清楚getFilesDir，getExternalFilesDir，getExternalStorageDirectory，getExternalStoragePublicDirectory等android文件操作方法，我将这些方法的执行结果打印出来，看看到底路径是啥样，在activity中执行以下代码： 123456Log.i(&quot;codecraeer&quot;, &quot;getFilesDir = &quot; + getFilesDir());Log.i(&quot;codecraeer&quot;, &quot;getExternalFilesDir = &quot; + getExternalFilesDir(&quot;exter_test&quot;).getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getDownloadCacheDirectory = &quot; + Environment.getDownloadCacheDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getDataDirectory = &quot; + Environment.getDataDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getExternalStorageDirectory = &quot; + Environment.getExternalStorageDirectory().getAbsolutePath());Log.i(&quot;codecraeer&quot;, &quot;getExternalStoragePublicDirectory = &quot; + Environment.getExternalStoragePublicDirectory(&quot;pub_test&quot;)); 在log中看到如下结果： 五、总结一张图总结，我个人的理解是存储按照不同的角度分为两种： 按照内外部：内部存储，外部存储 区别：带External字眼则一定是外部存储的方法，如getExternalFilesDir()，外部存储需要运行时权限 按照共有私有性质：公共文件，私有文件 区别：公共文件是Environment调用函数，而私有文件（包括内部私有与外部私有）是Context调用函数，公共文件不会随着app卸载而删除，私有则会。私有文件不会被Media Scanner扫描到。 引用 android中的文件操作详解以及内部存储和外部存储 http://developer.android.com/training/basics/data-storage/files.html#InternalVsExternalStorage http://developer.android.com/guide/topics/data/data-storage.html https://developer.android.com/about/versions/marshmallow/android-6.0.html"},{"title":"Android开罐头————ShapeDrawable详解","permalink":"http://www.youyuge.cn/2017/06/01/Android_ShapeDrawable/","text":"本文对shape这种drawable详细解析，从而可以简单地实现渐变，圆角矩形等等效果的背景。最后有示例。 Drawable种类繁多，ShapeDrawable 是一种很常见的Drawable,可以理解为通过颜色来构造的图形，它既可以是纯色的图形，也可以是具有渐变效果的图形。 一、ShapeDrawable语法ShapeDrawable语法稍显复杂，如下所示： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt; &lt;corners android:radius=&quot;integer&quot; android:topLeftRadius=&quot;integer&quot; android:topRightRadius=&quot;integer&quot; android:bottomLeftRadius=&quot;integer&quot; android:bottomRightRadius=&quot;integer&quot; /&gt; &lt;gradient android:angle=&quot;integer&quot; android:centerX=&quot;integer&quot; android:centerY=&quot;integer&quot; android:centerColor=&quot;integer&quot; android:endColor=&quot;color&quot; android:gradientRadius=&quot;integer&quot; android:startColor=&quot;color&quot; android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;] android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt; &lt;padding android:left=&quot;integer&quot; android:top=&quot;integer&quot; android:right=&quot;integer&quot; android:bottom=&quot;integer&quot; /&gt; &lt;size android:width=&quot;integer&quot; android:height=&quot;integer&quot; /&gt; &lt;solid android:color=&quot;color&quot; /&gt; &lt;stroke android:width=&quot;integer&quot; android:color=&quot;color&quot; android:dashWidth=&quot;integer&quot; android:dashGap=&quot;integer&quot; /&gt;&lt;/shape&gt; 需要注意的是&lt;shape&gt;标签创建的Drawable，其实体类实际上是GradientDrawable，下面分别介绍各个属性的含义。 二、各属性含义 android:shape根元素shape表示图形的形状，有四个选项： rectangle 矩形 oval 椭圆 line 横线 ring 圆环 另外四个当中，line 和 ring 一定需要通过&lt;stroke&gt;标签来指定线的宽和和颜色信息等。 &lt;corners&gt;表示shape图形四个交的角度，即四个角的圆角程度。单位是px，只适用于矩形shape。 android:radius优先级较低，会被其他四个属性覆盖。属性含义望文生义即可。注意：每个圆角半径值都必须大于1，否侧就没有圆角。 &lt;solid&gt;表示纯色填充，利用 android:color 就可以指定shape的颜色。 &lt;gradient&gt;渐变效果，和&lt;solid&gt;标签互斥。 gradient标签属性 作用 android:angle 渐变的角度，默认是0，其值必须是45的整数倍。0表示从左边到右，90表示从上到下。具体效果随着角度的调整而产生变化，角度影响渐变方向。 android:centerX 渐变中心的横坐标点 android:centerY 渐变中心的纵坐标点 android:startColor 渐变色的起始色 android:centerColor 渐变色的中间色 android:endColor 渐变色的结束色 android:type 渐变的类型，分3种，linear（线性渐变），radio（径向渐变），sweep（扫描线渐变），默认值是 线性渐变 。 android:gradientRadius 渐变的半径（仅当 android:type 为radio时有效） android:useLevel 一般为false，当Drawable作为StateListDrawable时有效。 &lt;stroke&gt;Shape的描边，有如下几个属性： stroke标签属性 作用 android:width 描边的宽度，越大则shape的边缘线越粗 android:color 描边的颜色 android:dashWidth 虚线的宽度 android:dashGap 虚线的空隙的间隔 注：如果 android:dashWidth 和 android:dashGap 两者有任意一个为0，那么虚线效果就无法显示。 &lt;padding&gt;不是shape的空白，而是包含它的View的空白 &lt;size&gt;shape没有宽/高的概念，总结来说，标签设置的宽高就是ShapeDrawable的固有宽高（这时调用getIntrinsicWidth获得的就不是-1了），但是作为View的背景时，它还是会拉伸或缩小自适应View的大小。 三、示例代码3.1 搜索框渐变背景：xml代码： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;@color/color_fed952&quot; android:endColor=&quot;#ff9b00&quot; /&gt;&lt;/shape&gt; 实际效果： 3.2 搜索框文字背景：xml代码： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;corners android:radius=&quot;6dp&quot;/&gt; &lt;solid android:color=&quot;@color/white&quot;/&gt;&lt;/shape&gt; 其实就是个editText的背景是白色的圆角矩形，配合上渐变背景，最后搜索框整体效果图： 3.3 搜索框布局文件代码xml代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;@drawable/bg_home_search&quot; android:padding=&quot;8dp&quot; &gt; &lt;TextView android:id=&quot;@+id/qrcode_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/bar_code_scan_icon&quot; /&gt; &lt;TextView android:id=&quot;@+id/category_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentRight=&quot;true&quot; android:layout_centerVertical=&quot;true&quot; android:background=&quot;@drawable/category&quot; /&gt; &lt;TextView android:id=&quot;@+id/search_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginRight=&quot;10dp&quot; android:layout_toLeftOf=&quot;@id/category_view&quot; android:layout_toRightOf=&quot;@id/qrcode_view&quot; android:background=&quot;@drawable/bg_home_edittext&quot; android:gravity=&quot;center&quot; android:padding=&quot;6dp&quot; android:text=&quot;@string/home_edittext_hint&quot; android:textColor=&quot;@color/color_cdcdcd&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/RelativeLayout&gt;"},{"title":"面试罐头（二）---- android插件化面试题","permalink":"http://www.youyuge.cn/2017/05/22/plugin-mianshi/","text":"1. 插件化来由1.1 方法数问题65536为方法数上限 2. 插件化所要解决的问题 动态加载apk 资源加载 代码加载"},{"title":"面试罐头(一)-——-okhttp内部总结分析","permalink":"http://www.youyuge.cn/2017/05/21/mianshi_1/","text":"本文意图是针对面试，理清内部流程关系，而非细抠代码，汇总他人的文字而来。 1.概述okhttp3总体流程图：先来回顾一下代码的使用流程，然后跟着流程一步步来分析： 1.1 创建 OkHttpClient 对象OkHttpClient client = new OkHttpClient(); 其实okHttpClient用的也是builder构建者模式： public OkHttpClient() { this(new Builder()); } 实际上，OkHttpClient.Builder 类成员很多，用来设置连接的各种参数，官方建议使用单例模式构建一个client，这样可以共用缓存和线程池。 直接new只是使用了默认配置： 1234567891011121314151617181920public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000;&#125; 1.2 创建Request请求对象封装了请求报文的信息，用构建者模式构建： Request request = new Request.Builder() .url(url) .build(); 1.3 创建Call对象OkHttpClient 实现了Call.Factory，负责根据请求创建新的 Call。如上图，表示的是链接client和request的桥梁。 callFactory 负责创建 HTTP 请求，HTTP 请求被抽象为了 okhttp3.Call 类，它表示一个已经准备好，可以随时执行的 HTTP 请求 Call call = client.newCall(request); 1.4 同步阻塞执行请求阻塞当前线程： Response response = call.execute(); 1.5 异步回调执行请求不会阻塞当前线程，会新开线程处理 call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { } @Override public void onResponse(Call call, Response response) throws IOException { System.out.println(response.body().string()); } }); 2. 精妙的线程池2.1 同步请求时实际上newCall方法会返回一个Realcall对象，而它同步执行execute()方法时： 12345678910111213141516@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(&quot;Already Executed&quot;); executed = true; &#125; try &#123; //仅仅标记作用 client.dispatcher().executed(this); //这才是真正的执行下一步发请求，同步异步都会走到这个方法 Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException(&quot;Canceled&quot;); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; 虽然dispatcher也掺和了，其实没什么用，涉及到 dispatcher 的内容只不过是在内部做了个标记，表明有个有个任务正在执行： 1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */ synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call); &#125; 2.2 异步请求2.2.1 反向代理模型服务器会添加Header并自动转发请求给后端集群，接着返回数据结果给用户。可以提高服务的负载均衡能力，实现非阻塞、高可用、高并发连接，避免资源全部放到一台服务器而带来的负载。 而在OkHttp中，非常类似于上述场景，它使用Dispatcher作为任务的派发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque&lt;readyAsyncCalls&gt;对应Nginx的内部缓存。 具体成员如下 maxRequests = 64: 最大并发请求数为64 maxRequestsPerHost = 5: 每个主机最大请求数为5 Dispatcher: 分发者，也就是生产者（默认在主线程） AsyncCall: 队列中需要处理的Runnable（包装了异步回调接口） ExecutorService：消费者池（也就是线程池） Deque&lt;readyAsyncCalls&gt;：缓存（用数组实现，可自动扩容，无大小限制） Deque&lt;runningAsyncCalls&gt;：正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存 通过将请求任务分发给多个线程，可以显著的减少I/O等待时间。 2.2.2 异步执行过程具体过程如下： enqueue()方法调用后，判断runningAsyncCalls队列是否还有空位子。 若有空位，那就调用executorService().execute(call);交给线程池执行请求，并且添加进运行队列 啊，没空位了，只能进readyAsyncCalls等待队列了…… 看一下call任务内部的执行方法： ………… //果然和同步方式一样，最后通过这个方法去发送给下一步。 Response response = getResponseWithInterceptorChain(forWebSocket); ………… finally { //最关键的代码 client.dispatcher().finished(this); } 当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数 123456if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //将缓存等待区最后一个移动到运行区中，并执行 i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; 实际上就是会在任务执行完的最后，把自己从运行队列移除，唤醒一个等待队列的任务，让他去执行。这样，就主动的把缓存队列向前走了一步，而没有使用互斥锁等复杂编码。 2.2.3 异步总结 OkHttp采用Dispatcher技术，反向代理，优化了单生产者多消费者模式，与线程池配合实现了高并发，低阻塞的运行 Okhttp采用Deque作为缓存，按照入队的顺序先进先出 OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以在任务结束时候唤醒等待的任务，主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性 3. 工作的核心—-拦截器3.1 拦截器的介绍与种类不管同步异步发送任务请求，最后都会执行getResponseWithInterceptorChain: 123456789101112131415161718private Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor( retryAndFollowUpInterceptor.isForWebSocket())); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 拦截器是个啥？官方介绍和图片： the whole thing is just a stack of built-in interceptors. 可见 Interceptor 是 OkHttp 最核心的一个东西，不要误以为它只负责拦截请求进行一些额外的处理（例如 cookie），实际上它把实际的网络请求、缓存、透明压缩等功能都统一了起来，每一个功能都只是一个 Interceptor，它们再连接成一个 Interceptor.Chain，环环相扣，最终圆满完成一次网络请求。 从 getResponseWithInterceptorChain 函数我们可以看到，Interceptor.Chain 的分布依次是： 在配置 OkHttpClient 时设置的 interceptors； 负责失败重试以及重定向的 RetryAndFollowUpInterceptor； 负责把用户构造的请求转换为发送到服务器的请求、把服务器返回的响应转换为用户友好的响应的 BridgeInterceptor； 负责读取缓存直接返回、更新缓存的 CacheInterceptor； 负责和服务器建立连接的 ConnectInterceptor； 配置 OkHttpClient 时设置的 networkInterceptors； 负责向服务器发送请求数据、从服务器读取响应数据的CallServerInterceptor。 3.2 拦截器的责任链模式实际上，是责任链模式的最佳应用（如同事件分发机制），每个拦截器可以自己拦截处理，或者交给下一个拦截器，让每个 Interceptor 自行决定能否完成任务以及怎么完成任务。 其实 Interceptor 的设计也是一种分层的思想，每个 Interceptor 就是一层。为什么要套这么多层呢？分层的思想在 TCP/IP 协议中就体现得淋漓尽致，分层简化了每一层的逻辑，每层只需要关注自己的责任（单一原则思想也在此体现），而各层之间通过约定的接口/协议进行合作（面向接口编程思想），共同完成复杂的任务。 4 总结 OkHttpClient 实现 Call.Factory，负责为 Request 创建 Call； RealCall 为具体的 Call 实现，其 enqueue() 异步接口通过 Dispatcher 利用 ExecutorService 实现，而最终进行网络请求时和同步 execute() 接口一致，都是通过 getResponseWithInterceptorChain() 函数实现； getResponseWithInterceptorChain() 中利用 Interceptor 链条，分层实现缓存、透明压缩、网络 IO 等功能； 引用 OkHttp3源码分析拆轮子系列：拆 OkHttp"},{"title":"hexo快速入门指南","permalink":"http://www.youyuge.cn/2017/05/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"第一篇博客，新的开始","permalink":"http://www.youyuge.cn/2017/05/10/my_first_post_test/","text":"欢迎来到尤晟的博客~ 1. 代码格式展示1.1 代码展示区123public void show()&#123;&#125;"}]}